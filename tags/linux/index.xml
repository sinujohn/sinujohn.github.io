<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Hack</title>
    <link>https://sinujohn.github.io/tags/linux/index.xml</link>
    <description>Recent content in Linux on Hack</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [PPOffice](http://github.com/ppoffice).</copyright>
    <atom:link href="https://sinujohn.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Run Windows programs on Linux</title>
      <link>https://sinujohn.github.io/2010/10/10/run-windows-programs-on-linux/</link>
      <pubDate>Sun, 10 Oct 2010 00:00:00 +0000</pubDate>
      
      <guid>https://sinujohn.github.io/2010/10/10/run-windows-programs-on-linux/</guid>
      <description>&lt;p&gt;&lt;p&gt;This is the most important question that a Linux newbie faces - &amp;ldquo;&lt;em&gt;How to run his/her favourite Windows application on Linux?&lt;/em&gt;&amp;rdquo; Well, here is a really short guide. For more help GIYF (Google Is Your Friend)!&lt;/p&gt;
&lt;h2&gt;1. Find the Linux versions of your Windows applications&lt;/h2&gt;
&lt;p&gt;If you are lucky you might find that the developers have also created a Linux version for their software. In this case, you are, hmm.. lucky!&lt;/p&gt;
&lt;h2&gt;2. Find the Linux equivalent of your Windows Application&lt;/h2&gt;
&lt;p&gt;If you can&amp;rsquo;t find a Linux version, you might find that there are many native Linux softwares that suites your need. This is true for various media players(VLC, Amarok etc. instead of Windows Media Player or Winamp), Graphics applications(GIMP instead of Photoshop) etc. In this case you&amp;rsquo;ll have to search for the new software(again GIYF), and once you have found one you&amp;rsquo;ll have to study how to use it.&lt;/p&gt;
&lt;h2&gt;3. Use Wine to run your Windows application&lt;/h2&gt;
&lt;p&gt;If you are not satisfied with neither of the above steps, try running your Windows application with Wine(Wine is a Linux application that reimplements Win32 API). This solution might not work 100% all the time. But still its worth giving a try because running your application with Wine is better than the solution of step4. And if you have got source code of your Windows application then you can port it to Linux using Winelib.&lt;/p&gt;
&lt;h2&gt;4. Use a virtual machine&lt;/h2&gt;
&lt;p&gt;If you want your application to work without any glitches (but with some performance overhead) then you can try installing a virtual machine with Windows OS loaded. You can then install your application in the virtual machine in the same way as you do in your Windows OS. VirtualBox is a really easy to use one. It provides seamless integration with your Linux desktop. Here is a screenshot of MS Paint in OpenSuSE with VirtualBox&amp;rsquo;s seamless integration enabled:&lt;/p&gt;
&lt;img src=&#34;https://sinujohn.github.io/assets/winlin.png&#34; alt=&#34;screenshot&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making ‘make’ work</title>
      <link>https://sinujohn.github.io/2010/09/04/making-make-work/</link>
      <pubDate>Sat, 04 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>https://sinujohn.github.io/2010/09/04/making-make-work/</guid>
      <description>&lt;p&gt;&amp;lsquo;make&amp;rsquo; is used to produce output files from several input files, although it is more usually used to compile programs.&lt;/p&gt;

&lt;p&gt;This is a very short note of &amp;lsquo;make&amp;rsquo; utility, mostly made for my own reference :). The best way to study is to look at makefiles! &amp;lsquo;Beginning Linux Programming&amp;rsquo; by Neil Matthew and Richard Stones is a good book to start linux programming. It also mentions &amp;lsquo;make&amp;rsquo; utility.&lt;/p&gt;

&lt;p&gt;&amp;lsquo;make&amp;rsquo; searches for a file &amp;lsquo;makefile&amp;rsquo; or &amp;lsquo;Makefile&amp;rsquo;. To use another filename with make use -f option.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -f Makefile4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h1&gt;Makefile Syntax&lt;/h1&gt;
Makefile is a set of Dependencies and Rules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dependencies:&lt;/strong&gt; It consist of two parts - Target file and the set of file on which target depends i.e. prerequisites.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rules:&lt;/strong&gt; This consist of the command that must be executed to obtain the Target file from the prerequisites.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Syntax is:&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;Target_name:&amp;lt;space or tab&amp;gt;Prerequisite1 [Prerequisite2 &amp;hellip;]&lt;/em&gt;&lt;br/&gt;
&lt;em&gt;&amp;lt;tab&amp;gt;Command_to_Execute&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Important: The Rule should be on a line that begins with TAB.
Comments begin with #&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myapp: main.o 2.o 3.o
    gcc -o myapp main.o 2.o 3.o

main.o: main.c a.h
    gcc -c main.c

2.o: 2.c a.h b.h
    gcc -c 2.c

3.o: 3.c b.h c.h
    gcc -c 3.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here myapp is the final executable. It depends on main.o, 2.o and 3.o.
main.o in turn depends on main.c and a.h. Similarly others.
Usually a Target called &lt;em&gt;&amp;lsquo;all&amp;rsquo;&lt;/em&gt; is used (as the first target). This is handy if more than one output files are required.
By default &amp;lsquo;make&amp;rsquo; tries to fulfill the first &amp;lsquo;Target&amp;rsquo;. So here &amp;lsquo;make&amp;rsquo; tries to obtain first target &amp;lsquo;myapp&amp;rsquo;. To obtain &amp;lsquo;myapp&amp;rsquo;, it requires main.o, 2.o and 3.o. So then it tries to obtain mao=in.o and so on.
We can also specify a specific target:
&lt;em&gt;make main.o&lt;/em&gt;
&lt;h1&gt;Macros in Makefile&lt;/h1&gt;
Defined by &lt;em&gt;MACRONAME=value&lt;/em&gt;
The value of a macro is accessed by &lt;em&gt;$(MACRONAME)&lt;/em&gt; or &lt;em&gt;${MACRONAME}&lt;/em&gt;. Some also support &lt;em&gt;$MACRONAME&lt;/em&gt;.
$(MACRONAME) is replaced with the value of the macro. &amp;lsquo;value&amp;rsquo; can be empty also.&lt;/p&gt;

&lt;p&gt;Commonly used macro names:&lt;/p&gt;

&lt;p&gt;CC                - Compiler&lt;/p&gt;

&lt;p&gt;INCLUDE  - Directory in which include files are present&lt;/p&gt;

&lt;p&gt;CFLAGS     - Compiler flags/options&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all: myapp
CC=gcc
CFLAGS= -g -Wall -ansi
# dot specifies current directory
INCLUDE=.

myapp: main.o 2.o
    $(CC) -o myapp main.o 2.o

main.o: main.c a.h
    $(CC) -I$(INCLUDE) $(CFLAGS) -c main.c

2.o: 2.c a.h b.h
    $(CC) -I$(INCLUDE) $(CFLAGS) -c 2.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;em&gt;$(CC) -I$(INCLUDE) $(CFLAGS) -c main.c&lt;/em&gt; is expanded to &lt;em&gt;gcc -I. -g -Wall -ansi -c main.c&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Predefined Macros:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$?              - List of prerequisites changed more recently than the target&lt;/p&gt;

&lt;p&gt;$@            - Name of current target&lt;/p&gt;

&lt;p&gt;$&amp;lt;             - Name of current prerequisite (Example - main.c)&lt;/p&gt;

&lt;p&gt;$*              - Name of current prerequisite without suffix (Example - main for main.c)&lt;/p&gt;

&lt;p&gt;Two other useful characters:&lt;/p&gt;

&lt;p&gt;&amp;rsquo;-&amp;rsquo; (minus sign)     - Ignore errors. For example, -mkdir ignores any error if the directory already exists.&lt;/p&gt;

&lt;p&gt;@                   - Tells &amp;lsquo;make&amp;rsquo; not to print the command to output. We may use echo to print instructions.&lt;/p&gt;

&lt;p&gt;&lt;h1&gt;Other Targets&lt;/h1&gt;
I have always wondered what is &amp;lsquo;&lt;em&gt;make clean&lt;/em&gt;&amp;rsquo; and &amp;lsquo;&lt;em&gt;make install&lt;/em&gt;&amp;rsquo; that we type while compiling programs from source. Its only now that I understood that &amp;lsquo;clean&amp;rsquo; and &amp;lsquo;install&amp;rsquo; are just other targets. So &amp;lsquo;make clean&amp;rsquo; and &amp;lsquo;make install&amp;rsquo; tries to achieve &amp;lsquo;clean&amp;rsquo; and &amp;lsquo;install&amp;rsquo; targets.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
...
clean:
    -rm main.o 2.o 3.o

install: myapp
    @if [ -d $(INSTDIR) ]; \
    then \
        cp myapp $(INSTDIR);\
        chmod a+x $(INSTDIR)/myapp;\
        echo &amp;quot;Installed in $(INSTDIR)&amp;quot;;\
    else \
        echo &amp;quot;Error: $(INSTDIR) does not exist&amp;quot;;\
    fi
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;clean&amp;rsquo; has no dependencies. So it is executed whenever the target &amp;lsquo;clean&amp;rsquo; is specified. The command &amp;lsquo;rm&amp;rsquo; is preceded by &amp;lsquo;-&amp;rsquo; to ignore the errors. Similarly we have used &amp;lsquo;@&amp;rsquo; before &amp;lsquo;if&amp;rsquo;.
Note: &amp;lsquo;[&amp;rsquo; is short for command &amp;lsquo;&lt;em&gt;test&lt;/em&gt;&amp;rsquo;. It is used for checking files. For more info, &amp;lsquo;&lt;em&gt;man test&lt;/em&gt;&amp;lsquo;
&lt;h1&gt;Built-in Rules&lt;/h1&gt;
&amp;lsquo;make&amp;rsquo; has several Built-in rules. You can see them by typing &amp;lsquo;&lt;em&gt;make -p&lt;/em&gt;&amp;rsquo;.
So makefile can simply be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.o: main.c a.h
2.o: 2.c a.h b.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The built-in rules are applied by looking at the file extensions(suffixes). We can add new suffix rules.
&lt;strong&gt;Syntax:&lt;/strong&gt;
&lt;em&gt;&amp;lt;old_suffix&amp;gt;.&amp;lt;new_suffix&amp;gt;:&lt;/em&gt;
Example for converting .cpp to .o files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.SUFFIXES: .cpp
.cpp.o:
    $(CC) -xc++ -I($INCLUDE) $(CFLAGS) -c $&amp;amp;lt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h1&gt;Libraries and &amp;lsquo;make&amp;rsquo;&lt;/h1&gt;
&amp;lsquo;make&amp;rsquo; has built-in rules to create and append to library(archive files created with &amp;lsquo;ar&amp;rsquo; command). To refer to file in the library use following syntax:
&lt;em&gt;libMyCol(foo.o)&lt;/em&gt;
This refers to file &lt;em&gt;foo.o&lt;/em&gt; as stored in library &lt;em&gt;libMyCol.a&lt;/em&gt;.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
MYLIB = libMyCol.a
...
...
myapp: main.o $(MYLIB)
    $(CC) -o myapp main.o $(MYLIB)
...
...
$(MYLIB): $(MYLIB)(2.o) $(MYLIB)(3.o)
main.o: main.c a.h
2.o: 2.c a.h b.h
3.o: 3.c b.h c.h
...
...
clean:
    -rm main.o 2.o 3.o

install: myapp
    @if [ -d $(INSTDIR) ]; \
    then \
        cp myapp $(INSTDIR);\
        chmod a+x $(INSTDIR)/myapp;\
        echo &amp;quot;Installed in $(INSTDIR)&amp;quot;;\
    else \
        echo &amp;quot;Error: $(INSTDIR) does not exist&amp;quot;;\
    fi
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h1&gt;A Useful Option&lt;/h1&gt;
Want to create dependency list easily? Use &lt;em&gt;-MM&lt;/em&gt; option with gcc. It produces a list which can be almost copy-pasted for use in a makefile!
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -MM main.c 2.c 3.c
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>A quick introduction to GCC</title>
      <link>https://sinujohn.github.io/2010/06/06/a-quick-introduction-to-gcc/</link>
      <pubDate>Sun, 06 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>https://sinujohn.github.io/2010/06/06/a-quick-introduction-to-gcc/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://gcc.gnu.org/&#34; target=&#34;_blank&#34;&gt;GCC&lt;/a&gt; - GNU Compiler Collection&lt;/strong&gt;
From GCC manual - &lt;em&gt;When you invoke GCC, it normally does preprocessing, compilation, assembly and linking.&lt;/em&gt;
&lt;h2&gt;Compile and Link a simple program:&lt;/h2&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o hello.out hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates an executable &amp;lsquo;hello.out&amp;rsquo; from file &amp;lsquo;hello.c&amp;rsquo;
-o specifies the output file.
&lt;h3&gt;&lt;strong&gt;Specify Language:&lt;/strong&gt;&lt;/h3&gt;
Create a C file and save it as &amp;lsquo;hello.cpp&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o hello.out hello.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This results in an error as gcc tries to perform C++ compilation(assumed from the extension .cpp).
We can specify that the file is a C file as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -x c -o hello.out hello.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-x specifies the language.
&lt;h3&gt;&lt;strong&gt;Compile Only(No Linking):&lt;/strong&gt;&lt;/h3&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -c hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-c tells gcc to compile ONLY. This creates &amp;lsquo;hello.o&amp;rsquo;, which is an object file.
&lt;h2&gt;Compiling and Linking multiple files:&lt;/h2&gt;
File: hello.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

long myabs(long);
long factorial(long);

int main()
{
 printf(&amp;quot;Hello World..\n&amp;quot;);
 printf(&amp;quot;Absolute(-3) = %d\nFactorial(5) = %d\n&amp;quot;,myabs(-3),factorial(5));
 return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File: myabs.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long myabs(long a)
{
 if(a&amp;lt;0) return -a;
 return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File: myfac.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long factorial(long no)
{
 if(no&amp;lt;=1) return 1;
 else return no*factorial(no-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;METHOD 1: Use source files directly:&lt;/strong&gt;
Make executable hello.out from 3 files by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c myabs.c myfac.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;METHOD 2: Use a source file with one or more object files:&lt;/strong&gt;
Compile one file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -c myabs.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now object code of myabs.c is obtained. Use this in usual gcc command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c myabs.o myfac.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can compile remaining files also and use their object files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c myabs.o myfac.o
 gcc -o hello.out hello.o myabs.o myfac.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Create Library:&lt;/h2&gt;
The above methods are suitable if the number of source files are really small. But if there are large number of source files, then its difficult to specify them each and every time you compile. To make this easy, you can create library.
Library is a collection of object files. Create library with &amp;lsquo;ar&amp;rsquo; command, which is short for &amp;lsquo;archive&amp;rsquo;.
So first create object files (.o files). With above example we have two object files - myabs.o and myfac.o. Now create library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ar cr libMyCol.a myabs.o myfac.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now a library libMyCol.a is created. To see the contents of a library use &amp;lsquo;ar t&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ar t libMyCol.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will show the present contents (myabs.o and myfac.o).&lt;/p&gt;

&lt;p&gt;Compile using the library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c libMyCol.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OR&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c -L. -lMyCol
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-L&lt;span style=&#34;text-decoration:underline;&#34;&gt;dir&lt;/span&gt; specifies the direcory in which library files are present. Here we use current directory, so we use a &amp;lsquo;dot&amp;rsquo; as directory.
-l&lt;span style=&#34;text-decoration:underline;&#34;&gt;library&lt;/span&gt; specifies the library name. library should only contain library name - extensions and preceeding &amp;lsquo;lib&amp;rsquo; is omitted. So here &amp;lsquo;libMyCol.a&amp;rsquo; is represented by -lMyCol   . This is why library names should start with &amp;lsquo;lib&amp;rsquo;.
&lt;h2&gt;Create Shared Library:&lt;/h2&gt;
To create shared libraries, object files must be created with -fPIC.
From gcc manual :
&lt;em&gt;-fpic
Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine.  Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system).  If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that -fpic does not work; in that case, recompile with -fPIC instead.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here we use -fPIC
Before continuing delete all files except the three C files - it looks nice to have a clean directory :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;STEP 1: Create object files as follows:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -c -fPIC myabs.c
 gcc -c -fPIC myfac.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;STEP 2: Now we create shared library or shared object(.so) file from the two .o files created above.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -shared -o libMyCol.so myabs.o myfac.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The shared library created is libMyCol.so. You can delete the .o files as they are no longer needed.&lt;/p&gt;

&lt;p&gt;The Shared Library can be linked either Statically or Dynamically.
&lt;h2&gt;Static Linking of Shared Library:&lt;/h2&gt;
&lt;strong&gt;METHOD 1: Give full path to .so file&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c ./libMyCol.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;METHOD 2: Use LD_LIBRARY_PATH environment variable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First set LD_LIBRARY_PATH variable to current directory (dot). Then export it. These two steps are shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LD_LIBRARY_PATH=.
 export LD_LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can perform the final compilation and linking as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c libMyCol.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Dynamic Linking of Shared Library:&lt;/h2&gt;
To do dynamic linking, you need to modify the source file &amp;lsquo;hello.c&amp;rsquo; as follows:&lt;/p&gt;

&lt;p&gt;File: hello.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;dlfcn.h&amp;gt;

typedef long (*FUN_PTR)(long);

int main()
{
 void *handle = dlopen(&amp;quot;libMyCol.so&amp;quot;,RTLD_LAZY);
 if(handle==0)
 {
  printf(&amp;quot;ERROR: Failed to load the library\n&amp;quot;);
  return -1;
 }
 FUN_PTR fptr1 = dlsym(handle,&amp;quot;myabs&amp;quot;);
 FUN_PTR fptr2 = dlsym(handle,&amp;quot;factorial&amp;quot;);
 if(fptr1==0 || fptr2==0)
 {
  printf(&amp;quot;ERROR: Cannot retrieve function address\n&amp;quot;);
  return -1;
 }
 long tp = (*fptr1)(-3);
 printf(&amp;quot;Hello World..\n&amp;quot;);
 printf(&amp;quot;Absolute(-3) = %d&amp;quot;,tp);
 tp = (*fptr2)(5);
 printf(&amp;quot;\nFactorial(5) = %d\n&amp;quot;,tp);
 dlclose(handle);
 return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you haven&amp;rsquo;t set LD_LIBRARY_PATH variable and exported it as mentioned above, then do it now.
Now perform dynamic linking by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c -ldl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dl is the dynamic linking library. -ldl asks gcc to use this library.&lt;/p&gt;

&lt;p&gt;Dynamic Linking library provides 4 functions - dlopen, dlclose, dlsym and dlerror. These are in dlfcn.h.
dlopen is used to open a .so file. It returns a handle to the file.
FUN_PTR is a function pointer. fptr1 has address of function myabs().
dlsym takes two parameters - handle and function name.
dlclose is used to close the .so file.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;http://praseedp.blogspot.com/&#34; target=&#34;_blank&#34;&gt;Praseed.P&lt;/a&gt; for his session on GCC at &lt;a href=&#34;http://www.ilug-cochin.org/&#34; target=&#34;_blank&#34;&gt;ILUG Cochin&lt;/a&gt;. It had been very informative and this post is a result of that session.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>