<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Hack</title>
    <link>https://sinujohn.github.io/tags/c/index.xml</link>
    <description>Recent content in C on Hack</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [PPOffice](http://github.com/ppoffice).</copyright>
    <atom:link href="https://sinujohn.github.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Boost and a look back on C&#43;&#43;</title>
      <link>https://sinujohn.github.io/2014/01/20/boost-and-a-look-back-on-c/</link>
      <pubDate>Mon, 20 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://sinujohn.github.io/2014/01/20/boost-and-a-look-back-on-c/</guid>
      <description>&lt;p&gt;These days am a full time Java guy and the last time I coded in C++ was a little over an year ago. It was then I came across Boost library and I had heard that it packed a lot under the 5 letter library BOOST. Even though I haven&amp;rsquo;t much used Boost, since it is being made part of the C++ standard, I don&amp;rsquo;t want to be a person who knew legacy C++ and so was always keen to know about Boost. And thats when I came across &lt;a href=&#34;http://www.packtpub.com/boost-cplusplus-application-development-cookbook/book&#34;&gt;this book on Boost&lt;/a&gt;. Its a cookbook style book which helps people who already know C++ and want to learn Boost. Here is my review on GoodReads :&lt;em&gt;
&lt;/em&gt;
&lt;a style=&#34;float:left;padding-right:20px;&#34; href=&#34;https://www.goodreads.com/book/show/18430596-boost-c-application-development-cookbook&#34;&gt;&lt;img alt=&#34;Boost C++ Application Development Cookbook&#34; src=&#34;https://d202m5krfqbpi5.cloudfront.net/books/1390102286m/18430596.jpg&#34; border=&#34;0&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;https://www.goodreads.com/book/show/18430596-boost-c-application-development-cookbook&#34;&gt;Boost C++ Application Development Cookbook&lt;/a&gt; by &lt;a href=&#34;https://www.goodreads.com/author/show/7250001.Antony_Polukhin&#34;&gt;Antony Polukhin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My rating: &lt;a href=&#34;https://www.goodreads.com/review/show/829027786&#34;&gt;5 of 5 stars&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;All those who want to use C++ in production will one day or other come across Boost Library. Being a coder who doesn&amp;rsquo;t use C++ as a primary language, but who wish to keep abreast of whats happening in the industry (and C++ is still not dead!), I always wanted to learn Boost. I had in fact downloaded boost about an year back, but haven&amp;rsquo;t used it much. A good tutorial was missing. And this cookbook definitely fills the void. It is not a beginners book who want to study C++. But its definitely an introduction to Boost. The author has made the cookbook way to give a very good introduction to Boost library.
What I liked: It is straight to the point. A no-nonsense book.
Boost is a large library and some of the it have been added in C++11. And some it is being said to be part of C++14. This itself tells that Boost is a library which every C++ programmer should be familiar of. And this cookbook is really a starting point to learning it. I should say that it is only the tip of the ice-berg, but it should make you capable of digging deep into the ice-berg&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.goodreads.com/review/list/17057121-sinu-john&#34;&gt;View all my reviews&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sending a file by HTTP POST</title>
      <link>https://sinujohn.github.io/2010/09/28/sending-a-file-by-http-post/</link>
      <pubDate>Tue, 28 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>https://sinujohn.github.io/2010/09/28/sending-a-file-by-http-post/</guid>
      <description>&lt;div id=&#34;_mcePaste&#34;&gt;Recently I created a program which can send a file to a server in several packets using&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;HTTP POST. I also created a servlet(in fact, my first servlet!) to receive these file&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;parts and then create a file using them. &lt;a href=&#34;http://www.box.net/shared/yf5hs3qanf&#34; target=&#34;_blank&#34;&gt;Download it&lt;/a&gt;.&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;The program &#39;client.c&#39; sends a file to the server as mentioned in small parts - 100KB, but&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;you can change the size (set value in SIZELIMIT). The program uses Curl library to&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;send the file using HTTP POST. Curl is very easy to use. They also have a great &lt;a href=&#34;http://curl.haxx.se/libcurl/c/libcurl-tutorial.html&#34; target=&#34;_blank&#34;&gt;tutorial&lt;/a&gt;.&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;The program sends each packet by attaching two additional headers to them - Count and Filename.&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;&#39;Count&#39; is used to set the count of the packet(starts from 1) and &#39;Filename&#39; is the name of the file that is being sent.&lt;/div&gt;
&lt;div&gt;File &#39;client.c&#39;:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/////////////////////////////////////////////////////////////
//client.c
// Send file to an HTTP server in small parts using POST
// USAGE: client inputfile
//
// Compile:
// gcc -o client client.c -lcurl
//
// Developer:
// Sinu John - https://sinujohn.github.io/
//
//////////////////////////////////////////////////////////////

#include&amp;lt;curl/curl.h&amp;gt;
#include&amp;lt;fcntl.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;

//No. of bytes to be sent in one pass
#define SIZELIMIT 100*1024

//#define _SEND_DEBUG_

int sendFile(const char *fileName, const char *url)  // Sends file to &#39;url&#39; with an additional header &#39;Count&#39; (specifying count of the packet)
{                                                    // An header &#39;Filename&#39; is also added
  int COUNT=0;
  int fd = open(fileName, O_RDONLY);
  if(fd&amp;lt;0)
  {
    printf(&amp;quot;\nERROR: Cannot open the file\n&amp;quot;);
    return -1;
  }

  CURL *handle;
  char buf[SIZELIMIT]; //Data to be sent is stored in this buffer. Static Allocation of memory.
  int ndata;
  struct curl_slist *headers=NULL;

  handle = curl_easy_init();

  #ifdef _SEND_DEBUG_
  curl_easy_setopt( handle, CURLOPT_VERBOSE, 1);
  #endif

  curl_easy_setopt( handle, CURLOPT_URL, url);

  while((ndata = read(fd, buf, SIZELIMIT))&amp;gt;0)
  {
    COUNT++;

    #ifdef _SEND_DEBUG_
    printf(&amp;quot;\n\n*****************************************************\n&amp;quot;);
    printf(&amp;quot;@@@@@@ Bytes Read = %d\n&amp;quot;, ndata);
    #endif

    ///////////////////////////////////////////////////////
    //////// Setting Count header and Filename header
    char countHeader[20], filenameHeader[50];
    headers=NULL;
    sprintf(countHeader,&amp;quot;Count:%d&amp;quot;,COUNT);
    sprintf(filenameHeader,&amp;quot;Filename:%s&amp;quot;,fileName);
    headers = curl_slist_append(headers, filenameHeader);
    headers = curl_slist_append(headers, &amp;quot;Expect:&amp;quot;);
    headers = curl_slist_append(headers, countHeader);
    curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers);
    /////////
    ///////////////////////////////////////////////////////B1

    curl_easy_setopt( handle, CURLOPT_POSTFIELDS, buf);
    curl_easy_setopt( handle, CURLOPT_POSTFIELDSIZE, ndata);
    curl_easy_perform( handle );

    ////////////////////////////////////////////////////////
    /////////// Freeing all headers
    curl_slist_free_all(headers);
    ///////////
    ////////////////////////////////////////////////////////B1
  }

  printf(&amp;quot;\n\n**** COUNT is %d ****\n\n&amp;quot;,COUNT);
  curl_easy_cleanup( handle );
  close(fd);
  return 0;
}

int main(int argc, char **argv)
{
  if(argc&amp;lt;2) { printf(&amp;quot;Please provide an input file\n&amp;quot;); return 1; }
  char *fileName = argv[1];
  sendFile(fileName, &amp;quot;http://localhost:8080/postapp/makeapp&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div id=&#34;_mcePaste&#34;&gt;The servlet &#39;MakeApp.java&#39;, is a very basic program that creates the file at the server from the several&lt;/div&gt;
&lt;div id=&#34;_mcePaste&#34;&gt;packets. I used Tomcat 6 to deploy it(My first encounter with Tomcat!).&lt;/div&gt;
&lt;div&gt;File &#39;MakeApp.java&#39;:&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;///////////////////////////////////////////////////////////////////////
//MakeApp.java
//Servlet for creating a file obtained as several parts
//through various POST requests.
//Creates the file in server folder (in my case: /usr/share/tomcat6/ )
//
//
// Developer: https://sinujohn.github.io/
//
//Compile:
//javac -cp /usr/share/tomcat6/lib/tomcat6-servlet-2.5-api-6.0.24.jar MakeApp.java
//
//////////////////////////////////////////////////////////////////////

import java.io.*;

import javax.servlet.http.*;
import javax.servlet.*;

public class MakeApp extends HttpServlet implements SingleThreadModel {
  public void doPost (HttpServletRequest req,
                                         HttpServletResponse res)
        throws ServletException, IOException
  {
	int count;
	String fileName;
	OutputStream fout;
	count=req.getIntHeader(&amp;quot;Count&amp;quot;);
	fileName = req.getHeader(&amp;quot;Filename&amp;quot;);
	if(count==1) { fout = new FileOutputStream(fileName); }
	else { fout = new FileOutputStream(fileName, true); }

	InputStream in = req.getInputStream();
	byte buf[] = new byte[req.getContentLength()+1];
	int nbuf;
	do
	{
	  nbuf = in.read(buf, 0, req.getContentLength());
	  if(nbuf&amp;gt;=0)  fout.write(buf, 0, nbuf);
	}while(nbuf&amp;gt;=0);

	fout.close();
        PrintWriter out = res.getWriter();
        out.println(&amp;quot;Got file &amp;quot;+fileName+&amp;quot; with Count: &amp;quot;+count);
        out.close();
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>A quick introduction to GCC</title>
      <link>https://sinujohn.github.io/2010/06/06/a-quick-introduction-to-gcc/</link>
      <pubDate>Sun, 06 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>https://sinujohn.github.io/2010/06/06/a-quick-introduction-to-gcc/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://gcc.gnu.org/&#34; target=&#34;_blank&#34;&gt;GCC&lt;/a&gt; - GNU Compiler Collection&lt;/strong&gt;
From GCC manual - &lt;em&gt;When you invoke GCC, it normally does preprocessing, compilation, assembly and linking.&lt;/em&gt;
&lt;h2&gt;Compile and Link a simple program:&lt;/h2&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o hello.out hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates an executable &amp;lsquo;hello.out&amp;rsquo; from file &amp;lsquo;hello.c&amp;rsquo;
-o specifies the output file.
&lt;h3&gt;&lt;strong&gt;Specify Language:&lt;/strong&gt;&lt;/h3&gt;
Create a C file and save it as &amp;lsquo;hello.cpp&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o hello.out hello.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This results in an error as gcc tries to perform C++ compilation(assumed from the extension .cpp).
We can specify that the file is a C file as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -x c -o hello.out hello.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-x specifies the language.
&lt;h3&gt;&lt;strong&gt;Compile Only(No Linking):&lt;/strong&gt;&lt;/h3&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -c hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-c tells gcc to compile ONLY. This creates &amp;lsquo;hello.o&amp;rsquo;, which is an object file.
&lt;h2&gt;Compiling and Linking multiple files:&lt;/h2&gt;
File: hello.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

long myabs(long);
long factorial(long);

int main()
{
 printf(&amp;quot;Hello World..\n&amp;quot;);
 printf(&amp;quot;Absolute(-3) = %d\nFactorial(5) = %d\n&amp;quot;,myabs(-3),factorial(5));
 return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File: myabs.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long myabs(long a)
{
 if(a&amp;lt;0) return -a;
 return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File: myfac.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long factorial(long no)
{
 if(no&amp;lt;=1) return 1;
 else return no*factorial(no-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;METHOD 1: Use source files directly:&lt;/strong&gt;
Make executable hello.out from 3 files by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c myabs.c myfac.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;METHOD 2: Use a source file with one or more object files:&lt;/strong&gt;
Compile one file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -c myabs.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now object code of myabs.c is obtained. Use this in usual gcc command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c myabs.o myfac.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can compile remaining files also and use their object files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c myabs.o myfac.o
 gcc -o hello.out hello.o myabs.o myfac.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Create Library:&lt;/h2&gt;
The above methods are suitable if the number of source files are really small. But if there are large number of source files, then its difficult to specify them each and every time you compile. To make this easy, you can create library.
Library is a collection of object files. Create library with &amp;lsquo;ar&amp;rsquo; command, which is short for &amp;lsquo;archive&amp;rsquo;.
So first create object files (.o files). With above example we have two object files - myabs.o and myfac.o. Now create library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ar cr libMyCol.a myabs.o myfac.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now a library libMyCol.a is created. To see the contents of a library use &amp;lsquo;ar t&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ar t libMyCol.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will show the present contents (myabs.o and myfac.o).&lt;/p&gt;

&lt;p&gt;Compile using the library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c libMyCol.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OR&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c -L. -lMyCol
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-L&lt;span style=&#34;text-decoration:underline;&#34;&gt;dir&lt;/span&gt; specifies the direcory in which library files are present. Here we use current directory, so we use a &amp;lsquo;dot&amp;rsquo; as directory.
-l&lt;span style=&#34;text-decoration:underline;&#34;&gt;library&lt;/span&gt; specifies the library name. library should only contain library name - extensions and preceeding &amp;lsquo;lib&amp;rsquo; is omitted. So here &amp;lsquo;libMyCol.a&amp;rsquo; is represented by -lMyCol   . This is why library names should start with &amp;lsquo;lib&amp;rsquo;.
&lt;h2&gt;Create Shared Library:&lt;/h2&gt;
To create shared libraries, object files must be created with -fPIC.
From gcc manual :
&lt;em&gt;-fpic
Generate position-independent code (PIC) suitable for use in a shared library, if supported for the target machine.  Such code accesses all constant addresses through a global offset table (GOT). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC; it is part of the operating system).  If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that -fpic does not work; in that case, recompile with -fPIC instead.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here we use -fPIC
Before continuing delete all files except the three C files - it looks nice to have a clean directory :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;STEP 1: Create object files as follows:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -c -fPIC myabs.c
 gcc -c -fPIC myfac.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;STEP 2: Now we create shared library or shared object(.so) file from the two .o files created above.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -shared -o libMyCol.so myabs.o myfac.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The shared library created is libMyCol.so. You can delete the .o files as they are no longer needed.&lt;/p&gt;

&lt;p&gt;The Shared Library can be linked either Statically or Dynamically.
&lt;h2&gt;Static Linking of Shared Library:&lt;/h2&gt;
&lt;strong&gt;METHOD 1: Give full path to .so file&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c ./libMyCol.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;METHOD 2: Use LD_LIBRARY_PATH environment variable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First set LD_LIBRARY_PATH variable to current directory (dot). Then export it. These two steps are shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LD_LIBRARY_PATH=.
 export LD_LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can perform the final compilation and linking as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c libMyCol.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Dynamic Linking of Shared Library:&lt;/h2&gt;
To do dynamic linking, you need to modify the source file &amp;lsquo;hello.c&amp;rsquo; as follows:&lt;/p&gt;

&lt;p&gt;File: hello.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;dlfcn.h&amp;gt;

typedef long (*FUN_PTR)(long);

int main()
{
 void *handle = dlopen(&amp;quot;libMyCol.so&amp;quot;,RTLD_LAZY);
 if(handle==0)
 {
  printf(&amp;quot;ERROR: Failed to load the library\n&amp;quot;);
  return -1;
 }
 FUN_PTR fptr1 = dlsym(handle,&amp;quot;myabs&amp;quot;);
 FUN_PTR fptr2 = dlsym(handle,&amp;quot;factorial&amp;quot;);
 if(fptr1==0 || fptr2==0)
 {
  printf(&amp;quot;ERROR: Cannot retrieve function address\n&amp;quot;);
  return -1;
 }
 long tp = (*fptr1)(-3);
 printf(&amp;quot;Hello World..\n&amp;quot;);
 printf(&amp;quot;Absolute(-3) = %d&amp;quot;,tp);
 tp = (*fptr2)(5);
 printf(&amp;quot;\nFactorial(5) = %d\n&amp;quot;,tp);
 dlclose(handle);
 return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you haven&amp;rsquo;t set LD_LIBRARY_PATH variable and exported it as mentioned above, then do it now.
Now perform dynamic linking by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; gcc -o hello.out hello.c -ldl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dl is the dynamic linking library. -ldl asks gcc to use this library.&lt;/p&gt;

&lt;p&gt;Dynamic Linking library provides 4 functions - dlopen, dlclose, dlsym and dlerror. These are in dlfcn.h.
dlopen is used to open a .so file. It returns a handle to the file.
FUN_PTR is a function pointer. fptr1 has address of function myabs().
dlsym takes two parameters - handle and function name.
dlclose is used to close the .so file.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;http://praseedp.blogspot.com/&#34; target=&#34;_blank&#34;&gt;Praseed.P&lt;/a&gt; for his session on GCC at &lt;a href=&#34;http://www.ilug-cochin.org/&#34; target=&#34;_blank&#34;&gt;ILUG Cochin&lt;/a&gt;. It had been very informative and this post is a result of that session.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>